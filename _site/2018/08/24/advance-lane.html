<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Advance lane detection using opencv &middot; Karth1kKumarK.github.io
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/Advance_lane_detection/public/css/poole.css">
  <link rel="stylesheet" href="/Advance_lane_detection/public/css/syntax.css">
  <link rel="stylesheet" href="/Advance_lane_detection/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/Advance_lane_detection/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/Advance_lane_detection/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/Advance_lane_detection/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
    

    <!-- <a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a> -->
    <a class="sidebar-nav-item" href="https://github.com/ossifier/Advance_lane_detection_code">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/Advance_lane_detection/" title="Home">Karth1kKumarK.github.io</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Advance lane detection using opencv</h1>
  <span class="post-date">24 Aug 2018</span>
  <p>This post describes process and code implementation required to achieve lane detection with rpi camera using opencv pipeline. The code is in jupyter notebook is available <a href="https://github.com/Karth1kKumarK/Advance_lane_detection_code" target="_blank">here</a>.
This project was inspired by Udacityâ€™s CarND-Advanced-Lane-Lines project.</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>Track</th>
    <th>Platform</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_detection/assets/images/IMG_20180824_170612.jpg" width="580px" /></td>
    <td><img src="/Advance_lane_detection/assets/images/car.png" width="280px" /></td>
  </tr>
</table>
<h3 id="the-steps-to-be-followed-to-achieve-objective-are">The steps to be followed to achieve objective are:</h3>
<ul>
  <li>calibration of rpi camera to obtain intrinsic camera parameters and distortion      coefficients.</li>
  <li>Apply distortion correction to image from rpi camera.</li>
  <li>Apply color mask,ROI to image to filter out unnecessary information</li>
  <li>Conversion to gray scale image and apply canny edge detection</li>
  <li>Apply a perspective transform to get bird eye view.</li>
  <li>Detect lane pixels and fit to find the lane boundary.</li>
  <li>Warp the lane boundary back on to original image</li>
</ul>

<h3 id="rpi-camera-calibration">Rpi Camera calibration:</h3>
<p>The image captured is 2D representation of 3D world,Hence this transformation from 3D to 2D is not ideal, This leads to distortion in image.Therefore camera calibration is required to obtain camera matrix and Distortion coefficients.for more information 
refer <a href="https://docs.opencv.org/3.1.0/dc/dbb/tutorial_py_calibration.html" target="_blank">this.</a></p>

<p>For camera calibration,I have used 7X9 checkerboard available <a href="https://www.mrpt.org/downloads/camera-calibration-checker-board_9x7.pdf" target="_blank">here</a>,capture the images of checker board in different orientation and place   them in a folder camera_01.Run the cameracalib.py(<strong>place camera_01 in the same directory as cameracalib.py</strong>)</p>

<div class="code-block">

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">nRows</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">nCols</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">dimension</span> <span class="o">=</span> <span class="mi">23</span>
<span class="n">workingFolder</span>   <span class="o">=</span> <span class="s">"./camera_01"</span>
<span class="n">imageType</span>       <span class="o">=</span> <span class="s">'jpg'</span>
<span class="c"># termination criteria</span>
<span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
<span class="c"># prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)</span>
<span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nRows</span><span class="o">*</span><span class="n">nCols</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">objp</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nRows</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nCols</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c"># Arrays to store object points and image points from all the images.</span>
<span class="n">objpoints</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># 3d point in real world space</span>
<span class="n">imgpoints</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># 2d points in image plane.</span>
<span class="n">filename</span>    <span class="o">=</span> <span class="n">workingFolder</span> <span class="o">+</span> <span class="s">"/*."</span> <span class="o">+</span> <span class="n">imageType</span>
<span class="n">images</span>      <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="c"># Find the chess board corners</span>
    <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="p">(</span><span class="n">nRows</span><span class="p">,</span><span class="n">nCols</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
    <span class="c"># If found, add object points, image points (after refining them)</span>
    <span class="k">if</span> <span class="n">ret</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">objpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span>
        <span class="n">corners2</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">cornerSubPix</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span><span class="n">corners</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">criteria</span><span class="p">)</span>
        <span class="n">imgpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="c"># Draw and display the corners</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">nRows</span><span class="p">,</span><span class="n">nCols</span><span class="p">),</span> <span class="n">corners2</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'img'</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
<span class="n">ret</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calibrateCamera</span><span class="p">(</span><span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">,</span> <span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">h</span><span class="p">,</span>  <span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">newcameramtx</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
 <span class="c"># undistort</span>
<span class="n">mapx</span><span class="p">,</span><span class="n">mapy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">initUndistortRectifyMap</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span><span class="n">dist</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">newcameramtx</span><span class="p">,(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span><span class="mi">5</span><span class="p">)</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">mapx</span><span class="p">,</span><span class="n">mapy</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>

    <span class="c"># crop the image</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">roi</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">w</span><span class="p">]</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">workingFolder</span> <span class="o">+</span> <span class="s">"/calibresult.png"</span><span class="p">,</span><span class="n">dst</span><span class="p">)</span>
<span class="n">filename</span> <span class="o">=</span> <span class="n">workingFolder</span> <span class="o">+</span> <span class="s">"/cameraMatrix.txt"</span>
<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">','</span><span class="p">)</span>
<span class="n">filename</span> <span class="o">=</span> <span class="n">workingFolder</span> <span class="o">+</span> <span class="s">"/cameraDistortion.txt"</span>
<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">','</span><span class="p">)</span>
<span class="n">mean_error</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objpoints</span><span class="p">)):</span>
    <span class="n">imgpoints2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">projectPoints</span><span class="p">(</span><span class="n">objpoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">imgpoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">imgpoints2</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">NORM_L2</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">imgpoints2</span><span class="p">)</span>
    <span class="n">mean_error</span> <span class="o">+=</span> <span class="n">error</span>
<span class="k">print</span><span class="p">(</span><span class="n">mean_error</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">objpoints</span><span class="p">))</span></code></pre></figure>

</div>

<p>After successful, Execution the cameraMatrix.txt and cameraDistortion.txt are saved in camera_01 folder.We will load this matrix into python space and pass them as argument 
into <strong>undistort</strong> function.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">mtx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">'/YOUR DIRECTORY/camera_01/cameraMatrix.txt'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">','</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">'/YOUR DIRECTORY/camera_01/cameraDistortion.txt'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">','</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span></code></pre></figure>

<table style="width:100%; border:0px;">
  <tr>
    <th>Distorted</th>
    <th>Undistorted</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_detection/assets/images/snapshot_640_480_20.jpg" width="280px" /></td>
    <td><img src="/Advance_lane_detection/assets/images/calibresult.png" width="280px" /></td>
  </tr>
</table>

<p>The undistort function applies distortion correction to the image
(<strong>the image returned from this function is croped after distortion correction</strong>)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">undistort</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">mtx</span><span class="p">,</span><span class="n">dist</span><span class="p">):</span><span class="c">#function for un distorting the image wrt to camera                                        #parameters </span>
                             <span class="c">#obtained from camera calibration</span>
        <span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">newcameramtx</span><span class="p">,</span><span class="n">roi</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span> 
        <span class="n">dst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">undistort</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">newcameramtx</span><span class="p">)</span>
        <span class="c"># crop the image</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">roi</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">w</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dst</span></code></pre></figure>

<h3 id="apply-color-maskroi-to-image-to-filter-out-unnecessary-information">Apply color mask,roi to image to filter out unnecessary information</h3>

<p>In the the current project because of the Color of the left,right lane are same.
Hence color mask and the Region of interest)( <strong>ROI</strong>) is applied to the image, The information other than the ROI and bandwidth of the color mask  is eliminated.The bandwidth for the upper and lower limit of color mask was found through trail and error.</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>Undisort image</th>
    <th>ROI image</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_detection/assets/images/Undistort.png" width="480px" /></td>
    <td><img src="/Advance_lane_detection/assets/images/ROIimage.png" width="280px" /></td>
  </tr>
</table>
<div class="code-block"> 

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">color_filter</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="c">#convert to HLS to mask based on HLS</span>
    <span class="n">hls</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2HLS</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">105</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">50</span><span class="p">])</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">125</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="mi">115</span><span class="p">])</span>
    <span class="n">yellower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span><span class="mi">215</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c">#lower limit </span>
    <span class="n">yelupper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">])</span>
    <span class="n">yellowmask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="n">hls</span><span class="p">,</span> <span class="n">yellower</span><span class="p">,</span> <span class="n">yelupper</span><span class="p">)</span>
    <span class="n">whitemask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="n">hls</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">yellowmask</span><span class="p">,</span> <span class="n">whitemask</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked</span>
    
    <span class="k">def</span> <span class="nf">ROI</span><span class="p">(</span><span class="n">img1</span><span class="p">):</span>   <span class="c"># function to get region of interest in a image</span>
    <span class="n">img</span><span class="o">=</span><span class="n">maskedimage</span><span class="o">=</span><span class="n">color_filter</span><span class="p">(</span><span class="n">img1</span><span class="p">)</span>
    <span class="c">#change the ppoly coordinate according the camera mount</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">250</span><span class="p">],[</span><span class="mi">640</span><span class="p">,</span><span class="mi">250</span><span class="p">],[</span><span class="mi">640</span><span class="p">,</span><span class="mi">480</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">480</span><span class="p">]])</span>
    <span class="c">#define a numpy array with the dimensions of img, but comprised of zeros</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="c">#Uses 3 channels or 1 channel for color depending on input image</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">channel_count</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ignore_mask_color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,)</span> <span class="o">*</span> <span class="n">channel_count</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ignore_mask_color</span> <span class="o">=</span> <span class="mi">255</span>
    <span class="c">#creates a polygon with the mask color</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">shape</span><span class="p">]),</span> <span class="n">ignore_mask_color</span><span class="p">)</span>
    <span class="c">#returns the image only where the mask pixels are not zero</span>
    <span class="n">masked_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_image</span></code></pre></figure>

</div>

<h3 id="conversion-to-gray-scale-image-and-apply-canny-edge-detection">conversion to gray scale image and apply canny edge detection</h3>
<p>The ROI image obtained is now converted into grayscale and canny edge detection algorithm is applied.</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>Gray scale image </th>
    <th>Canny edge</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_detection/assets/images/greyscale.png" width="280px" /></td>
    <td><img src="/Advance_lane_detection/assets/images/canny.png" width="280px" /></td>
  </tr>
</table>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">greyimage</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">ROIimage</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>
<span class="n">cannyimage</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">greyimage</span><span class="p">,</span><span class="mi">100</span> <span class="p">,</span><span class="mi">80</span><span class="p">)</span></code></pre></figure>

<h3 id="apply-a-perspective-transform-to-get-bird-eye-viewbev">Apply a perspective transform to get bird eye view(BEV)</h3>
<p>The perspective transformation will give us top down view of the track.
This is important for estimation of curvature radius in case of curved 
track. To get BEV we want to select four source pointâ€™s in trapezoidal shape
which we want to get the top down view</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>Canny edge </th>
    <th>Bird Eye view</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_detection/assets/images/canny.png" width="280px" /></td>
    <td><img src="/Advance_lane_detection/assets/images/birdeye.png" width="280px" /></td>
  </tr>
</table>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">birdeyeview</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="c">#cv2.circle(frame, (155, 280), 5, (0, 0, 255), -1)</span>
    <span class="c">##these  points are for  visualization</span>
    <span class="c">#cv2.circle(frame, (500, 280), 5, (0, 0, 255), -1)</span>
    <span class="c">#cv2.circle(frame, (5, 435), 5, (0, 0, 255), -1)</span>
    <span class="c">#cv2.circle(frame, (605, 435), 5, (0, 0, 255), -1)</span>
    <span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">155</span><span class="p">,</span> <span class="mi">280</span><span class="p">],[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">280</span><span class="p">],[</span><span class="mi">605</span><span class="p">,</span> <span class="mi">435</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">435</span><span class="p">]])</span>
    <span class="n">pts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">605</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">605</span><span class="p">,</span><span class="mi">440</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">440</span><span class="p">]])</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="p">(</span><span class="mi">605</span><span class="p">,</span><span class="mi">440</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span><span class="n">matrix</span></code></pre></figure>

<h3 id="detect-lane-pixels-and-fit-to-find-the-lane-boundary">Detect lane pixels and fit to find the lane boundary</h3>
<p>The lane detection relies on extraction of lane pixel and to  fit the curve to  get the  curvature and that in turn can we used to compute steering angles.
The approach used here is  to get histogram of the lower half of the
image to get the range of position of pixels in the image.
Then dividing the entire image into n(current n=9) of windows.
Using the function <strong>Yourimage.nonzero()</strong> to get x ,y co ordinates of non zero pixels is determined.In the current window with width =100,Window boundaries in x and y is determined, then within this window non zero pixel location is found.these pixels are categorized  based on the boundaries of window,Hence extracting left and right lane pixels.
Now x and y co ordinate of right and left lane pixels are determined, we use Curve fitting to obtain the polynomial.
<img src="/Advance_lane_detection/assets/images/lane_detect.png" width="480px" /></p>
<div class="code-block"> 

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">extract_lanes_pixels</span><span class="p">(</span><span class="n">binary_warped</span><span class="p">):</span>

        <span class="c"># Take a histogram of the bottom half of the image</span>
        <span class="n">histogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">binary_warped</span><span class="p">[</span><span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#plt.plot(histogram)</span>
        <span class="c">#plt.show()</span>
        <span class="c"># Create an output image to draw on and  visualize the result</span>
        <span class="n">out_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">))</span><span class="o">*</span><span class="mi">255</span>
        <span class="c"># Find the peak of the left and right halves of the histogram</span>
        <span class="c"># These will be the starting point for the left and right lines</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">histogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">leftx_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">histogram</span><span class="p">[:</span><span class="n">midpoint</span><span class="p">])</span>
        <span class="n">rightx_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">histogram</span><span class="p">[</span><span class="n">midpoint</span><span class="p">:])</span> <span class="o">+</span> <span class="n">midpoint</span>

        <span class="c"># Choose the number of sliding windows</span>
        <span class="n">nwindows</span> <span class="o">=</span> <span class="mi">9</span>
        <span class="c"># Set height of windows</span>
        <span class="n">window_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nwindows</span><span class="p">)</span>
        <span class="c"># Identify the x and y positions of all nonzero pixels in the image</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">nonzeroy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nonzerox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c"># Current positions to be updated for each window</span>
        <span class="n">leftx_current</span> <span class="o">=</span> <span class="n">leftx_base</span>
        <span class="n">rightx_current</span> <span class="o">=</span> <span class="n">rightx_base</span>
        <span class="c"># Set the width of the windows +/- margin</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c"># Set minimum number of pixels found to recenter window</span>
        
        <span class="c"># Create empty lists to receive left and right lane pixel indices</span>
        <span class="n">left_lane_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">right_lane_inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Step through the windows one by one</span>
        <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwindows</span><span class="p">):</span>
            <span class="c"># Identify window boundaries in x and y (and right and left)</span>
            <span class="n">win_y_low</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">window_height</span>
            <span class="n">win_y_high</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span><span class="o">*</span><span class="n">window_height</span>
            <span class="n">win_xleft_low</span> <span class="o">=</span> <span class="n">leftx_current</span> <span class="o">-</span> <span class="n">margin</span>
            <span class="n">win_xleft_high</span> <span class="o">=</span> <span class="n">leftx_current</span> <span class="o">+</span> <span class="n">margin</span>
            <span class="n">win_xright_low</span> <span class="o">=</span> <span class="n">rightx_current</span> <span class="o">-</span> <span class="n">margin</span>
            <span class="n">win_xright_high</span> <span class="o">=</span> <span class="n">rightx_current</span> <span class="o">+</span> <span class="n">margin</span>
            <span class="c"># Draw the windows on the visualization image</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">out_img</span><span class="p">,(</span><span class="n">win_xleft_low</span><span class="p">,</span><span class="n">win_y_low</span><span class="p">),(</span><span class="n">win_xleft_high</span><span class="p">,</span><span class="n">win_y_high</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">out_img</span><span class="p">,(</span><span class="n">win_xright_low</span><span class="p">,</span><span class="n">win_y_low</span><span class="p">),(</span><span class="n">win_xright_high</span><span class="p">,</span><span class="n">win_y_high</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="c"># Identify the nonzero pixels in x and y within the window</span>
            <span class="n">good_left_inds</span> <span class="o">=</span> <span class="p">((</span><span class="n">nonzeroy</span> <span class="o">&gt;=</span> <span class="n">win_y_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzeroy</span> <span class="o">&lt;</span> <span class="n">win_y_high</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&gt;=</span> <span class="n">win_xleft_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&lt;</span> <span class="n">win_xleft_high</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">good_right_inds</span> <span class="o">=</span> <span class="p">((</span><span class="n">nonzeroy</span> <span class="o">&gt;=</span> <span class="n">win_y_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzeroy</span> <span class="o">&lt;</span> <span class="n">win_y_high</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&gt;=</span> <span class="n">win_xright_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&lt;</span> <span class="n">win_xright_high</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Append these indices to the lists</span>
            <span class="n">left_lane_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_left_inds</span><span class="p">)</span>
            <span class="n">right_lane_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_right_inds</span><span class="p">)</span>
            <span class="c"># If you found &gt; minpix pixels, recenter next window on their mean position</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_left_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">minpix</span><span class="p">:</span>
                <span class="n">leftx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nonzerox</span><span class="p">[</span><span class="n">good_left_inds</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_right_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">minpix</span><span class="p">:</span>        
                <span class="n">rightx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nonzerox</span><span class="p">[</span><span class="n">good_right_inds</span><span class="p">]))</span>

        <span class="c"># Concatenate the arrays of indices</span>
        <span class="n">left_lane_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">left_lane_inds</span><span class="p">)</span>
        <span class="n">right_lane_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">right_lane_inds</span><span class="p">)</span>

        <span class="c"># Extract left and right line pixel positions</span>
        <span class="n">leftx</span> <span class="o">=</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]</span>
        <span class="n">lefty</span> <span class="o">=</span> <span class="n">nonzeroy</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]</span> 
        <span class="n">rightx</span> <span class="o">=</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]</span>
        <span class="n">righty</span> <span class="o">=</span> <span class="n">nonzeroy</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]</span> 

        <span class="k">return</span> <span class="n">leftx</span><span class="p">,</span> <span class="n">lefty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="n">righty</span><span class="p">,</span> <span class="n">left_lane_inds</span><span class="p">,</span> <span class="n">right_lane_inds</span>

<span class="k">def</span> <span class="nf">poly_fit</span><span class="p">(</span><span class="n">leftx</span><span class="p">,</span> <span class="n">lefty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="n">righty</span><span class="p">,</span> <span class="n">left_lane_inds</span><span class="p">,</span> <span class="n">right_lane_inds</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span><span class="bp">False</span><span class="p">):</span>  

        <span class="c"># Fit a second order polynomial to each</span>
        <span class="n">left_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">lefty</span><span class="p">,</span> <span class="n">leftx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">right_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">righty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c"># Generate x and y values for plotting</span>
        <span class="n">ploty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">left_fitx</span> <span class="o">=</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span> <span class="o">+</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">right_fitx</span> <span class="o">=</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span> <span class="o">+</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c"># Identify the x and y positions of all nonzero pixels in the image</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">nonzeroy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nonzerox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">out_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">))</span><span class="o">*</span><span class="mi">255</span>
        <span class="n">out_img</span><span class="p">[</span><span class="n">nonzeroy</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">],</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">out_img</span><span class="p">[</span><span class="n">nonzeroy</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">],</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>

        <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">out_img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">left_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'yellow'</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">right_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'yellow'</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">540</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">left_fit</span><span class="p">,</span> <span class="n">right_fit</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">left_fitx</span><span class="p">,</span> <span class="n">right_fitx</span></code></pre></figure>

</div>

<h3 id="warp-the-lane-boundary-back-on-to-original-image">Warp the lane boundary back on to original image</h3>
<p>Now that lane curves are detected we will use 
cv2.fillPoly(color_warp, np.int_([pts]), (0,255,0))
to fill image along curve. After this step,Image is 
inverse perspective transformed into original view plane and 
combined with the  original undistorted image.
<img src="/Advance_lane_detection/assets/images/final.png" /></p>
<div class="code-block">

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">plain_lane</span><span class="p">(</span><span class="n">undist</span><span class="p">,</span> <span class="n">warped</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">left_fitx</span><span class="p">,</span> <span class="n">right_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
        <span class="n">Minv</span> <span class="o">=</span> <span class="n">inv</span> <span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c"># Create an image to draw the lines on</span>
        <span class="n">warp_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">warped</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">color_warp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">warp_zero</span><span class="p">,</span> <span class="n">warp_zero</span><span class="p">,</span> <span class="n">warp_zero</span><span class="p">))</span>
        
        <span class="c"># Recast the x and y points into usable format for cv2.fillPoly()</span>
        <span class="n">pts_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">left_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">]))])</span>
        <span class="n">pts_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">right_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">])))])</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pts_left</span><span class="p">,</span> <span class="n">pts_right</span><span class="p">))</span>
        
        <span class="c"># Draw the lane onto the warped blank image</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">color_warp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">([</span><span class="n">pts</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="c"># Warp the blank back to original image space using inverse perspective matrix (Minv)</span>
        <span class="n">newwarp</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">color_warp</span><span class="p">,</span> <span class="n">Minv</span><span class="p">,</span> <span class="p">(</span><span class="n">warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> 
        <span class="c">#newwarp=undistorth(newwarp)</span>
        <span class="c"># Combine the result with the original image</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">undist</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newwarp</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
            
        
        <span class="k">return</span> <span class="n">result</span>


 <span class="k">def</span> <span class="nf">render_curvature_and_offset</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">curverad</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>   
        <span class="c"># Add curvature and offset information</span>
        <span class="n">offst_text</span> <span class="o">=</span> <span class="s">'offset: {:.2f}m'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">font</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">offst_text</span><span class="p">,</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">font</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">curverad_text</span> <span class="o">=</span> <span class="s">'curverad: {:.2f}m'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curverad</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">curverad_text</span><span class="p">,</span> <span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span> <span class="n">font</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rundist_image</span></code></pre></figure>

</div>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
